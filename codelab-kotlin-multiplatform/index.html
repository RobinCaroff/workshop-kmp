
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Workshop Kotlin Multiplatform</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="???"
                  id="codelab-kotlin-multiplatform"
                  title="Workshop Kotlin Multiplatform"
                  environment="web"
                  feedback-link="https://github.com/RobinCaroff/workshop-kmp">
    
      <google-codelab-step label="CodeLab Overview" duration="2">
        <h3 is-upgraded>Sharing Kotlin code between iOS and Android</h3>
<p>In this codelab you will create an iOS and Android application, by making use of Kotlin&#39;s code sharing features.<br>For Android you&#39;ll be using Kotlin/JVM, while for iOS it will be Kotlin/Native.</p>
<p>This codelab will show you the ability to share code within Kotlin and the benefits it provides. While what we&#39;ll be looking at is a simplified application, what is shown here can be applied to real world applications, independent of their size or complexity.</p>
<p>You will learn how to:</p>
<h3 is-upgraded>Create an Android app with Android Studio</h3>
<h3 is-upgraded>Create a shared Kotlin library</h3>
<ul>
<li>Use it from Android app</li>
<li>Start the Android application</li>
</ul>
<h3 is-upgraded>Create an iOS app with Xcode</h3>
<ul>
<li>Use the shared Kotlin library from iOS app</li>
<li>Use Kotlin from Swift</li>
<li>Start the iOS application</li>
</ul>
<h3 is-upgraded>Improve the shared library</h3>
<ul>
<li>Use Coroutines to validate the asynchronous ability</li>
<li>Use the multiplatform Http client Ktor to call a Json Api</li>
</ul>
<aside class="special"><p>This codelab is inspired by the Jetbrains <a href="https://kotlinlang.org/docs/tutorials/native/mpp-ios-android.html" target="_blank">tutorial</a> for the first steps. The jetbrains codelab is more detailled on the initial configuration of the project and has very interesting focus on the graddle files.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Environment Setup" duration="4">
        <p>You need <a href="https://developer.android.com/studio/" target="_blank">Android Studio</a> 3.4+ for the Android part of the tutorial.</p>
<aside class="warning"><p>⚠️ Kotlin MPP is broken with 3.5.1. Please use 3.5.0 or 3.6 preview releases ⚠️</p>
</aside>
<aside class="special"><p>You can also use <a href="https://jetbrains.com/idea/" target="_blank">IntelliJ IDEA</a> Community or Ultimate edition.</p>
</aside>
<p>The Kotlin plugin 1.3.41 or higher should be installed in the IDE. This can be verified via Language &amp; Frameworks | Kotlin Updates section in the Settings (or Preferences) window.</p>
<p>For the iOS part of the tutorial, you need a macOS 10.14+ host with Xcode 10.3+ and the tools installed and configured.</p>
<aside class="warning"><p>If you don&#39;t fill in the requirements at least for the Android part, please consider pair programming !!!</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="STEP ONE - Initialize the project" duration="10">
        <h3 is-upgraded>In this step, we check that everything is well configured !</h3>
<p>Clone the workshop project repository :</p>
<pre><code>git clone https://github.com/mlumeau/workshop-kmp.git
</code></pre>
<p>Checkout the branch <code>step_one_setup</code> :</p>
<pre><code>cd workshop-kmp
git checkout step_one_setup
</code></pre>
<p>This project contain an Android app, a library and an iOS project.</p>
<h3 is-upgraded>Launch the Android Studio IDE and open the project.</h3>
<p>The project should sync and you should be able to compile and run the Android application on an emulator or a real device.</p>
<h3 is-upgraded>Let&#39;s check that it works!</h3>
<p>You should see a blank screen :<br><img alt="image_caption" src="img/6adc87008ad3b6f0.png"></p>
<aside class="special"><p>In the project, you can see the kore module which will contain the code for the multiplatform Android/iOS library.</p>
</aside>
<h3 is-upgraded>For Mac users :</h3>
<p>First you have to prepare the framework for iOS</p>
<pre><code>./gradlew :kore:packForXCode 
</code></pre>
<p>It creates the directory <code>kore/build/xcode-frameworks</code> which contains a gradlew executable and the framework for Xcode.</p>
<p>Now install the pods :</p>
<pre><code>cd iosApp/kosmos
pod install
</code></pre>
<aside class="warning"><p>In case of errors, try to reinstall pods with the last version of cocoapods</p>
</aside>
<pre><code>sudo gem install cocoapods
pod deintegrate
rm Podfile.lock
pod install
</code></pre>
<h3 is-upgraded>Now you can open the project in Xcode</h3>
<p>by opening the workspace file : <code>../workshop-kmp/iosApp/kosmos/kosmos.xcworkspace</code></p>
<p>You can now compile and run the project on an iOS emulator or on a real device.</p>
<p>You should see a blank screen :<br><img alt="image_caption" src="img/56d554d56953538c.png"></p>
<h3 is-upgraded>If everything&#39;s fine, let&#39;s go to the second step !!!</h3>


      </google-codelab-step>
    
      <google-codelab-step label="STEP TWO - A very basic KMP project" duration="12">
        <h3 is-upgraded>In this step, you will implement your first multiplatform code !</h3>
<p>The goal of this step is to define a common method which creates a greetings text and adds spécific implementations for iOS and Android in the Kotlin common code.</p>
<p>As a result, we will creates an Android module and an iOS framework both exposing the same method <code>createApplicationScreenMessage</code> but having different implementation.</p>
<aside class="special"><p>You may have to switch the type of View in the Android Studio Explorer during the codelab :<br><strong>Project</strong> View for editing the Kore Library<br><strong>Android</strong> View for editing the Android App</p>
</aside>
<p>First add this code in the common directory of the kore library : <code>kore/src/commonMain/kotlin/xyz/mlumeau/kosmos/kore/common.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore

expect fun platformName(): String

fun createApplicationScreenMessage(): String {
    return &#34;Kotlin Rocks on ${platformName()}&#34;
}
</code></pre>
<aside class="special"><p>The keyword <code>expect</code> means that you have to implement these function in the specific code (the <code>actual</code> code).</p>
</aside>
<p>Now edit the android directory : <code>workshop-kmp/kore/src/androidMain/kotlin/xyz/mlumeau/kosmos/kore/actual.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore

actual fun platformName(): String {
    return &#34;Android&#34;
}
</code></pre>
<aside class="special"><p>The keyword <code>actual</code> corresponds to the <code>expect</code> in the specific code.</p>
</aside>
<p>In the Android main project &#34;androidApp&#34;, update the MainActivity :</p>
<p>Add a TextView in <code>res/layout/activity_main.xml</code></p>
<pre><code>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;

&lt;RelativeLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
        xmlns:tools=&#34;http://schemas.android.com/tools&#34;
        android:layout_width=&#34;match_parent&#34;
        android:layout_height=&#34;match_parent&#34;
        tools:context=&#34;.views.MainActivity&#34;&gt;

    &lt;TextView
            android:id=&#34;@+id/title_tv&#34;
            android:textStyle=&#34;bold&#34;
            android:layout_width=&#34;wrap_content&#34;
            android:layout_height=&#34;wrap_content&#34;
            android:layout_centerInParent=&#34;true&#34; /&gt;

&lt;/RelativeLayout&gt;
</code></pre>
<p>Handle this textview in <code>java/xyz.mlumeau.kosmos.views/MainActivity</code> (Kotlin file)</p>
<pre><code>package xyz.mlumeau.kosmos.views

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import kotlinx.android.synthetic.main.activity_main.*
import xyz.mlumeau.kosmos.R
import xyz.mlumeau.kosmos.kore.createApplicationScreenMessage

class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        title_tv.text = createApplicationScreenMessage()
    }
}
</code></pre>
<p>Run it and you should see :<br><img alt="image_caption" src="img/a761533ae237d64a.png"></p>
<h3 is-upgraded>For Mac users :</h3>
<p>Now edit the iOS directory : <code>workshop-kmp/kore/src/iosMain/kotlin/xyz/mlumeau/kosmos/kore/actual.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore

import platform.UIKit.UIDevice

actual fun platformName(): String {
    return UIDevice.currentDevice.systemName() +
            &#34; &#34; +
            UIDevice.currentDevice.systemVersion
}
</code></pre>
<p>Back to Xcode !</p>
<p>If you are familiar with Storyboard, add a &#34;titleTV&#34; TextView in the center of the MainView and set the reference to the MainViewController.titleTV @IBOutlet.<br>If you prefer, download the <a href="https://github.com/mlumeau/workshop-kmp/blob/step_three_localrepository/iosApp/kosmos/kosmos/Base.lproj/Main.storyboard" target="_blank">storyboard from the next step</a>.</p>
<p>And then update the MainViewController to handle the &#34;titleTV&#34; textView</p>
<pre><code>import UIKit
import Nuke
import kore

class MainViewController: UIViewController {
    
    @IBOutlet weak var titleTV: UITextView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.titleTV.text = CommonKt.createApplicationScreenMessage()
    }

    override var preferredStatusBarStyle: UIStatusBarStyle {
        return self.style
    }
    var style:UIStatusBarStyle = .default
}

</code></pre>
<p>You can now compile and run the project on an iOS emulator or on a real device.<br><img alt="image_caption" src="img/3ad1739a7b43816a.png"></p>
<h3 is-upgraded>If everything&#39;s fine, let&#39;s go to the step 3 !!!</h3>


      </google-codelab-step>
    
      <google-codelab-step label="STEP THREE - Local Repository" duration="20">
        <h3 is-upgraded>In this step, you will implement a local repository to simulate a call to the Nasa API APOD - &#34;Astronomy Picture Of the Day&#34; !</h3>
<p>First create a common Model : <code>kore/src/commonMain/kotlin/xyz/mlumeau/kosmos/kore/model/APOD.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore.model

import kotlinx.serialization.Optional
import kotlinx.serialization.Serializable

@Serializable
data class APOD(
    @Optional val explanation: String? = null,
    @Optional val media_type: String? = null,
    @Optional val title : String? = null,
    @Optional val url: String? = null
)
</code></pre>
<p>Now the repository cache interface : <code>.../kore/data/APODRepositoryCache.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore.data

import xyz.mlumeau.kosmos.kore.model.APOD

interface APODRepositoryCache {
    suspend fun getAPOD(): APOD?
    fun getAPOD(completion: (APOD) -&gt; Unit, failure: () -&gt; Unit)
}
</code></pre>
<p>Notice that we create to methods with the same purpose.</p>
<aside class="special"><p>The <code>suspend</code> keyword is not supported in Swift. As we are going to take advantage of coroutines, the Android app will call the <code>suspend</code> method but the iOS one will call the regular method with a callback system.</p>
</aside>
<p>And the implementation : <code>.../kore/data/APODRepositoryCacheImpl.kt</code> which contains the APOD stub in its companion object.</p>
<pre><code>package xyz.mlumeau.kosmos.kore.data

import kotlinx.serialization.json.Json
import xyz.mlumeau.kosmos.kore.model.APOD
import xyz.mlumeau.kosmos.kore.requestAPOD

class APODRepositoryCacheImpl : APODRepositoryCache {

    override suspend fun getAPOD(): APOD? = Json.nonstrict.parse(APOD.serializer(), APOD_STUB)

    override fun getAPOD(completion: (APOD) -&gt; Unit, failure: () -&gt; Unit) {
        requestAPOD(this, completion, failure)
    }

    companion object {
        private const val APOD_STUB =
            &#34;{\&#34;date\&#34;:\&#34;2019-08-31\&#34;,\&#34;explanation\&#34;:\&#34;Few cosmic vistas excite the imagination like the Orion Nebula, an immense stellar nursery some 1,500 light-years away. Spanning about 40 light-years across the region, this infrared image from the Spitzer Space Telescope was constructed from data intended to monitor the brightness of the nebula&#39;s young stars, many still surrounded by dusty, planet-forming disks. Orion&#39;s young stars are only about 1 million years old, compared to the Sun&#39;s age of 4.6 billion years. The region&#39;s hottest stars are found in the Trapezium Cluster, the brightest cluster near picture center. Launched into orbit around the Sun on August 25, 2003 Spitzer&#39;s liquid helium coolant ran out in May 2009. The infrared space telescope continues to operate though, its mission scheduled to end on January 30, 2020. Recorded in 2010, this false color view is from two channels that still remain sensitive to infrared light at Spitzer&#39;s warmer operating temperatures.\&#34;,\&#34;hdurl\&#34;:\&#34;https://apod.nasa.gov/apod/image/1908/orion2010_spitzer.jpg\&#34;,\&#34;media_type\&#34;:\&#34;image\&#34;,\&#34;service_version\&#34;:\&#34;v1\&#34;,\&#34;title\&#34;:\&#34;Spitzer&#39;s Orion\&#34;,\&#34;url\&#34;:\&#34;https://apod.nasa.gov/apod/image/1908/orion2010_spitzerMedRC.jpg\&#34;}&#34;
    }
}
</code></pre>
<p>Update the common file : <code>.../kore/common.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore

import xyz.mlumeau.kosmos.kore.data.APODRepositoryCacheImpl


expect fun platformName(): String

fun createApplicationScreenMessage(): String {
    return &#34;Kotlin Rocks on ${platformName()}&#34;
}

expect fun requestAPOD(
    apodRepositoryCache: APODRepositoryCacheImpl,
    completion: (APOD) -&gt; Unit,
    failure: () -&gt; Unit
)
</code></pre>
<p>Now edit the android directory : <code>workshop-kmp/kore/src/androidMain/kotlin/xyz/mlumeau/kosmos/kore/actual.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore

import xyz.mlumeau.kosmos.kore.data.APODRepositoryCacheImpl

actual fun platformName(): String {
    return &#34;Android&#34;
}

actual fun requestAPOD(
    apodRepositoryCache: APODRepositoryCacheImpl,
    completion: (APOD) -&gt; Unit,
    failure: () -&gt; Unit
) {
    TODO(&#34;The Android app must use the suspend function instead.&#34;)
}
</code></pre>
<p>Now that we have a data model and a repository to provide it, we will create the user interface to display the data content.</p>
<p>Let&#39;s start with the Android application. In the Android main project &#34;androidApp&#34;, update the MainActivity :</p>
<p>Remove the TextView and add an Image, a title, a text and a progressbar in <code>res/layout/activity_main.xml</code></p>
<pre><code>&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;

&lt;RelativeLayout
        xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;
        xmlns:tools=&#34;http://schemas.android.com/tools&#34;
        xmlns:app=&#34;http://schemas.android.com/apk/res-auto&#34;
        android:layout_width=&#34;match_parent&#34;
        android:layout_height=&#34;match_parent&#34;
        tools:context=&#34;.views.MainActivity&#34;&gt;
    &lt;ScrollView android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;wrap_content&#34;&gt;
        &lt;androidx.constraintlayout.widget.ConstraintLayout
                android:layout_width=&#34;match_parent&#34;
                android:layout_height=&#34;wrap_content&#34;
                android:paddingBottom=&#34;16dp&#34;&gt;

            &lt;ImageView android:id=&#34;@+id/apod_iv&#34;
                       android:layout_width=&#34;match_parent&#34;
                       android:layout_height=&#34;0dp&#34;
                       android:scaleType=&#34;centerCrop&#34;
                       app:layout_constraintDimensionRatio=&#34;1:1&#34;
                       app:layout_constraintTop_toTopOf=&#34;parent&#34;
                       android:contentDescription=&#34;@string/astronomy_picture_of_the_day&#34;/&gt;

            &lt;TextView
                    android:id=&#34;@+id/title_tv&#34;
                    android:textStyle=&#34;bold&#34;
                    android:layout_width=&#34;wrap_content&#34;
                    android:layout_height=&#34;wrap_content&#34;
                    app:layout_constraintLeft_toLeftOf=&#34;parent&#34;
                    app:layout_constraintRight_toRightOf=&#34;parent&#34;
                    android:layout_marginTop=&#34;32dp&#34; app:layout_constraintTop_toBottomOf=&#34;@+id/apod_iv&#34;
                    android:layout_marginLeft=&#34;16dp&#34; android:layout_marginRight=&#34;16dp&#34;/&gt;
            &lt;TextView
                    android:id=&#34;@+id/desc_tv&#34;
                    android:layout_width=&#34;0dp&#34;
                    android:layout_height=&#34;wrap_content&#34;
                    android:ellipsize=&#34;end&#34;
                    app:layout_constraintLeft_toLeftOf=&#34;parent&#34;
                    app:layout_constraintRight_toRightOf=&#34;parent&#34;
                    app:layout_constraintStart_toStartOf=&#34;parent&#34; android:layout_marginStart=&#34;16dp&#34;
                    app:layout_constraintEnd_toEndOf=&#34;parent&#34; android:layout_marginEnd=&#34;16dp&#34;
                    android:layout_marginTop=&#34;16dp&#34;
                    app:layout_constraintTop_toBottomOf=&#34;@+id/title_tv&#34;/&gt;

        &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
    &lt;/ScrollView&gt;

    &lt;ProgressBar
            android:id=&#34;@+id/progress&#34;
            android:indeterminate=&#34;true&#34;
            android:layout_width=&#34;wrap_content&#34; android:layout_height=&#34;wrap_content&#34;
            app:layout_constraintEnd_toEndOf=&#34;parent&#34; android:layout_marginEnd=&#34;8dp&#34;
            android:layout_centerInParent=&#34;true&#34;
            /&gt;

&lt;/RelativeLayout&gt;
</code></pre>
<p>Handle these views in <code>java/xyz.mlumeau.kosmos.views/MainActivity</code> (Kotlin file)</p>
<pre><code>package xyz.mlumeau.kosmos.views

import android.os.Bundle
import android.view.View
import androidx.appcompat.app.AppCompatActivity
import com.squareup.picasso.Picasso
import kotlinx.android.synthetic.main.activity_main.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import xyz.mlumeau.kosmos.R
import xyz.mlumeau.kosmos.kore.model.APOD
import xyz.mlumeau.kosmos.kore.createApplicationScreenMessage
import xyz.mlumeau.kosmos.kore.data.APODRepositoryCache
import xyz.mlumeau.kosmos.kore.data.APODRepositoryCacheImpl

class MainActivity : AppCompatActivity() {

    private val apodRepository: APODRepositoryCache = APODRepositoryCacheImpl()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        title_tv.text = createApplicationScreenMessage()

        getAPOD()
    }

    private fun updateAPODData(apod: APOD) {
        title_tv.text = apod.title
        desc_tv.text = apod.explanation
        if (apod.media_type == &#34;image&#34; &amp;&amp; !apod.url.isNullOrEmpty()) {
            Picasso.get().load(apod.url).fit().centerCrop().into(apod_iv)
        } else {
            apod_iv.visibility = View.GONE
        }
        progress.visibility = View.GONE
    }

    private fun getAPOD() {
        GlobalScope.launch {
            apodRepository.getAPOD()?.let { apod -&gt;
                withContext(Dispatchers.Main) {
                    updateAPODData(apod)
                }
            }
        }
    }
}
</code></pre>
<p>Run it and you should see :<br><img alt="image_caption" src="img/3caccf69e2656ac6.png"></p>
<h3 is-upgraded>For Mac users :</h3>
<p>We will now create the user interface for the iOS application.</p>
<p>Now edit the iOS directory by creating a &#34;dispatchers&#34; file : <code>workshop-kmp/kore/src/iosMain/kotlin/xyz/mlumeau/kosmos/kore/dispatchers.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore

import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.Runnable
import platform.darwin.dispatch_async
import platform.darwin.dispatch_get_main_queue
import kotlin.coroutines.CoroutineContext


internal class MainDispatcher: CoroutineDispatcher() {
    override fun dispatch(context: CoroutineContext, block: Runnable) {
        dispatch_async(dispatch_get_main_queue()) {
            block.run()
        }
    }
}

internal abstract class Scope(
    private val dispatcher: CoroutineDispatcher
) : CoroutineScope {
    private val job = Job()

    override val coroutineContext: CoroutineContext
        get() = dispatcher + job

}

internal class MainScope : Scope(MainDispatcher())
</code></pre>
<aside class="special"><p>On iOS, we need to create a dispatcher that will handle our coroutine on the main dispatch queue. Notice that we use the dispatch_async() and dispatch_get_main_queue() functions that should sound familiar if you have worked with the Grand Central Dispatch on iOS before.<br></p>
</aside>
<p>Now edit the iOS actual file : <code>workshop-kmp/kore/src/iosMain/kotlin/xyz/mlumeau/kosmos/kore/actual.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore

import kotlinx.coroutines.launch
import platform.UIKit.UIDevice
import xyz.mlumeau.kosmos.kore.data.APODRepositoryCacheImpl

actual fun platformName(): String {
    return UIDevice.currentDevice.systemName() +
            &#34; &#34; +
            UIDevice.currentDevice.systemVersion
}

actual fun requestAPOD(
    apodRepositoryCache: APODRepositoryCacheImpl,
    completion: (APOD) -&gt; Unit,
    failure: () -&gt; Unit
) {
    MainScope().launch {
        val apod = apodRepositoryCache.getAPOD()
        if (apod != null) {
            completion(apod)
        } else {
            failure()
        }
    }
}
</code></pre>
<p>Back to Xcode !</p>
<p>If you are familiar with Storyboard, add the progressbar, UIImageView and another textview for description in the MainView (see picture below) and add references to the MainViewController.<br><img alt="image_caption" src="img/b4fb544c213212b6.png"><br>If you prefer, download the <a href="https://github.com/mlumeau/workshop-kmp/blob/step_four_remoterepository/iosApp/kosmos/kosmos/Base.lproj/Main.storyboard" target="_blank">storyboard from the next step</a>.</p>
<p>And then update the <code>MainViewController</code> code...</p>
<pre><code>import UIKit
import Nuke
import kore

class MainViewController: UIViewController {

    @IBOutlet weak var apodIV: UIImageView!
    @IBOutlet weak var titleTV: UITextView!
    @IBOutlet weak var descTV: UITextView!
    @IBOutlet weak var progress: UIActivityIndicatorView!
    
    private let apodRepository: APODRepositoryCache = APODRepositoryCacheImpl()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        startLoadingData()
    }
    
    override var preferredStatusBarStyle: UIStatusBarStyle {
        return self.style
    }
    var style:UIStatusBarStyle = .default

}

private extension MainViewController {
    
    private func startLoadingData() {
        apodRepository.getAPOD(completion: { apod in
            self.updateAPODData(apod: apod)
            return .init()
        }, failure: { () in
            self.onLoadingError()
            return .init()
        })
    }
    
    func updateAPODData(apod: APOD) {
        let url = URL(string: apod.url ?? &#34;&#34;)
        self.titleTV.text = apod.title
        self.descTV.text = apod.explanation
        if(apod.media_type == &#34;image&#34;){
            Nuke.loadImage(with: url!, into: self.apodIV)
        } else {
            //self.apodIV.frame = CGRect(x: 0,y: 0,width: 0,height: 0)
        }
        self.progress.isHidden = true
    }
    
    func onLoadingError() {}
}
</code></pre>
<p>You can now compile and run the project on an iOS emulator or on a real device.<br><img alt="image_caption" src="img/e0141634d78c0ad9.png"></p>
<h3 is-upgraded>If everything&#39;s fine, let&#39;s go to the step 4 !!!</h3>


      </google-codelab-step>
    
      <google-codelab-step label="STEP FOUR - Call the remote API" duration="15">
        <h3 is-upgraded>In this step, you will implement a remote repository to call the Nasa API APOD - &#34;Astronomy Picture Of the Day&#34; !</h3>
<p>First create the Nasa API service interface : <code>.../kore/service/nasa/NasaApi.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore.service.nasa

import xyz.mlumeau.kosmos.kore.APOD

internal interface NasaApi {
    suspend fun getAPOD(): APOD?
}
</code></pre>
<p>And the implementation : <code>.../kore/service/nasa/NasaApiRemote.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore.service.nasa

import io.ktor.client.HttpClient
import io.ktor.client.call.call
import io.ktor.client.response.readText
import io.ktor.http.HttpMethod
import kotlinx.serialization.json.Json
import xyz.mlumeau.kosmos.kore.service.nasa.NasaApi


internal class NasaAPIRemote(
    private val client: HttpClient = HttpClient()
) : NasaApi {

    private suspend fun request(urlString: String): String {
        return client.call(urlString) {
            method = HttpMethod.Get
        }.response.readText()
    }

    private suspend fun requestAPOD() : APOD {
        val result = request(APOD_URL)

        return Json.nonstrict.parse(APOD.serializer(), result)
    }

    override suspend fun getAPOD(): APOD = requestAPOD()

    companion object {
        const val APOD_URL = &#34;https://api.nasa.gov/planetary/apod?&amp;api_key=DEMO_KEY&#34;
    }
}
</code></pre>
<p>Now create the remote repository interface : <code>.../kore/data/APODRepositoryRemote.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore.data

import xyz.mlumeau.kosmos.kore.model.APOD

interface APODRepositoryRemote {
    suspend fun getAPOD(): APOD?
    fun getAPOD(completion: (APOD) -&gt; Unit, failure: () -&gt; Unit)
}
</code></pre>
<p>And the implementation : <code>.../kore/data/APODRepositoryRemoteImpl.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore.data

import xyz.mlumeau.kosmos.kore.model.APOD
import xyz.mlumeau.kosmos.kore.NasaAPIRemote
import xyz.mlumeau.kosmos.kore.requestAPOD
import xyz.mlumeau.kosmos.kore.service.nasa.NasaApi

class APODRepositoryRemoteImpl : APODRepositoryRemote {
    private val nasaAPI: NasaApi = NasaAPIRemote()

    override suspend fun getAPOD() = nasaAPI.getAPOD()

    override fun getAPOD(completion: (APOD) -&gt; Unit, failure: () -&gt; Unit) {
        requestAPOD(this, completion, failure)
    }
}
</code></pre>
<p>Update the common file : <code>.../kore/common.kt</code><br>Add a new function requestApod with a APODRepositoryRemoteImpl parameter.<br>Do not remove the other requestApod function !</p>
<pre><code>package xyz.mlumeau.kosmos.kore

...
import xyz.mlumeau.kosmos.kore.data.APODRepositoryRemoteImpl

...
expect fun requestAPOD(
    apodRepositoryRemote: APODRepositoryRemoteImpl,
    completion: (APOD) -&gt; Unit,
    failure: () -&gt; Unit
)
</code></pre>
<p>Now edit the android directory : <code>workshop-kmp/kore/src/androidMain/kotlin/xyz/mlumeau/kosmos/kore/actual.kt</code><br>Add a new function requestApod with a APODRepositoryRemoteImpl parameter.<br>Do not remove the other requestApod function !</p>
<pre><code>package xyz.mlumeau.kosmos.kore

...
import xyz.mlumeau.kosmos.kore.data.APODRepositoryRemoteImpl

...
actual fun requestAPOD(
    apodRepositoryRemote: APODRepositoryRemoteImpl,
    completion: (APOD) -&gt; Unit,
    failure: () -&gt; Unit
) {
    TODO(&#34;The Android app must use the suspend function instead.&#34;)
}
</code></pre>
<p>In the Android main project &#34;androidApp&#34;, update the <code>java/xyz.mlumeau.kosmos.views/MainActivity</code> (Kotlin file) by replacing the Cache repository with Remote Repository :</p>
<pre><code>...
import xyz.mlumeau.kosmos.kore.data.APODRepositoryRemote
import xyz.mlumeau.kosmos.kore.data.APODRepositoryRemoteImpl

class MainActivity : AppCompatActivity() {

    private val apodRepository: APODRepositoryRemote = APODRepositoryRemoteImpl()
...
</code></pre>
<p>Run it and you should see a new picture : the Astronomy picture of the day !<br>Take some time to celebrate 🎉!!!</p>
<h3 is-upgraded>For Mac users :</h3>
<p>Now edit the iOS actual file : <code>workshop-kmp/kore/src/iosMain/kotlin/xyz/mlumeau/kosmos/kore/actual.kt</code><br>Add a requestAPOD function for Remote Repository.</p>
<pre><code>package xyz.mlumeau.kosmos.kore

...
import kotlinx.coroutines.CoroutineScope
import xyz.mlumeau.kosmos.kore.data.APODRepositoryRemoteImpl

...
fun getNetworkScope() = MainScope() as CoroutineScope

actual fun requestAPOD(
    apodRepositoryRemote: APODRepositoryRemoteImpl,
    completion: (APOD) -&gt; Unit,
    failure: () -&gt; Unit
) {
    getNetworkScope().launch {
        val apod = apodRepositoryRemote.getAPOD()
        if (apod != null) {
            completion(apod)
        } else {
            failure()
        }
    }
}
</code></pre>
<p>Back to Xcode !</p>
<p>Update the <code>MainViewController</code> code by replacing the Cache Repository by a Remote Repository :</p>
<pre><code>...
class MainViewController: UIViewController {

    ...
    private let apodRepository: APODRepositoryRemote = APODRepositoryRemoteImpl()
 
</code></pre>
<p>You can now compile and run the project on an iOS emulator or on a real device to see the new picture of the day !<br>iOS celebration time 🥳!!!</p>
<h3 is-upgraded>If everything&#39;s fine, let&#39;s go to the step 5 !!!</h3>


      </google-codelab-step>
    
      <google-codelab-step label="STEP FIVE - Architecture" duration="12">
        <h3 is-upgraded>In this step, you will implement a better architecture in native apps !</h3>
<aside class="warning"><p>If you&#39;re in a hurry, you can skip this step and go directly to <a href="/codelab-kotlin-multiplatform/#7" target="_blank">Step 6</a>. 😉</p>
</aside>
<p>Nothing to do in the Kore library this time !</p>
<p>In the Android main project &#34;androidApp&#34;, create a viewmodels directory.</p>
<p>Add a new class : <code>.../viewmodels/APODViewModel.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.viewmodels

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import xyz.mlumeau.kosmos.kore.model.APOD
import xyz.mlumeau.kosmos.kore.data.APODRepositoryRemote

class APODViewModel(
    private val apodRepository: APODRepositoryRemote
) : ScopedViewModel() {

    private var job: Job? = null

    private val _apod = MutableLiveData&lt;APOD&gt;()
    val apod: LiveData&lt;APOD&gt;
        get() = _apod

    init {
        startLoadingData()
    }

    override fun onCleared() {
        super.onCleared()
        job?.cancel()
    }

    private fun startLoadingData() {
        launch {
            apodRepository.getAPOD()?.let { apod -&gt;
                withContext(Dispatchers.Main) {
                    _apod.value = apod
                }
            }
        }
    }
}
</code></pre>
<p>Add a factory : <code>.../viewmodels/APODViewModelFactory.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.viewmodels

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import xyz.mlumeau.kosmos.kore.data.APODRepositoryRemoteImpl

class APODViewModelFactory : ViewModelProvider.Factory {

    @Suppress(&#34;UNCHECKED_CAST&#34;)
    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {
        require(modelClass == APODViewModel::class.java) { &#34;Unknown ViewModel class&#34; }
        return APODViewModel(
            APODRepositoryRemoteImpl()
        ) as T
    }
}
</code></pre>
<p>And a Scopped view model : <code>.../viewmodels/ScopedViewModel.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.viewmodels

import androidx.lifecycle.ViewModel
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlin.coroutines.CoroutineContext

abstract class ScopedViewModel : ViewModel(),
    CoroutineScope {
    private val job = Job()
    val parentJob: Job
        get() = job

    override val coroutineContext: CoroutineContext
        get() = Dispatchers.Main + job

    override fun onCleared() {
        super.onCleared()
        parentJob.cancel()
    }
}
</code></pre>
<p>update the <code>java/xyz.mlumeau.kosmos.views/MainActivity</code> (Kotlin file) by replacing the getApod() function with a call to the ViewModel  :</p>
<pre><code>...
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModelProviders
import xyz.mlumeau.kosmos.viewmodels.APODViewModel
import xyz.mlumeau.kosmos.viewmodels.APODViewModelFactory

class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        title_tv.text = createApplicationScreenMessage()

        // getApod()
        val model =
            ViewModelProviders.of(this, APODViewModelFactory())[APODViewModel::class.java]
        model.apod.observe(this, Observer { apod -&gt; updateAPODData(apod) })
    }
</code></pre>
<p>The function getApod() can be removed.</p>
<p>Run it to validate the new architecture.</p>
<h3 is-upgraded>For Mac users :</h3>
<p>Back to Xcode !</p>
<p>Create a ViewModels directory.</p>
<p>Add a new class : <code>.../ViewModels/MainViewModel.kt</code></p>
<pre><code>import Foundation
import kore

final class MainViewModel {
    private let apodRepository: APODRepositoryRemote = APODRepositoryRemoteImpl()
    var apod: APOD? = nil
    var onAPODLoaded: ((APOD) -&gt; ())? = nil
    var onLoadingError: (() -&gt; ())? = nil
    
    init() {
        startLoadingData()
    }
    
    private func startLoadingData() {
        apodRepository.getAPOD(completion: { apod in
            self.apod = apod
            self.onAPODLoaded?(apod)
            return .init()
        }, failure: { () in
            self.onLoadingError?()
            return .init()
        })
    }
}
</code></pre>
<p>Update the <code>MainViewController</code> code by replacing the Repository by the View Model :</p>
<pre><code>...
    // private let apodRepository: APODRepositoryRemote = APODRepositoryRemoteImpl()
    let viewModel = MainViewModel()

    override func viewDidLoad() {
        super.viewDidLoad()
        // startLoadingData()
        configureUI()
        configureBinding()
    }
 
 ...

 private extension MainViewController {
    
//    private func startLoadingData() {
//        apodRepository.getAPOD(completion: { apod in
//            self.updateAPODData(apod: apod)
//            return .init()
//        }, failure: { () in
//            self.onLoadingError()
//            return .init()
//        })
//    }
    func configureUI() {
    }
    
    func configureBinding() {
        viewModel.onAPODLoaded = updateAPODData
        viewModel.onLoadingError = onLoadingError
    }
...
</code></pre>
<p>You can now compile and run the project to validate the architecture updates !</p>
<h3 is-upgraded>If everything&#39;s fine, let&#39;s go to the step 6 !!!</h3>


      </google-codelab-step>
    
      <google-codelab-step label="STEP SIX - A dedicated Use Case" duration="15">
        <h3 is-upgraded>In this step, you will implement a dedicated use case for retreiving the APOD data in the Kore Library !</h3>
<p>To follow up with on the previous step and follow the single responsability principle, we will create a use case to retrieve APOD data. The main goal is to abstract the logic behind this operation. No needs for the final app to know how the data will be retrieved.</p>
<aside class="special"><p>The <code>GetAPOD</code> use case will handle the logic of choosing between the remote and the cache repository based on whether or not an internet connection is available.</p>
</aside>
<p>First create a usecase GetAPOD : <code>.../kore/usecases/GetAPOD.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.usecases

import xyz.mlumeau.kosmos.kore.APOD

interface GetAPOD {
    suspend operator fun invoke(): APOD?
    fun getAPOD(completion: (APOD) -&gt; Unit, failure: () -&gt; Unit)
}
</code></pre>
<p>, a usecase GetConnectionState : <code>.../kore/usecases/GetConnectionState.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore.usecases

interface GetConnectionState {
    fun isConnectedToNetwork(): Boolean
}
</code></pre>
<p>and the GetAPOD implementation : <code>.../kore/usecases/implementations/GetAPODImpl.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore.usecases.implementations

import xyz.mlumeau.kosmos.kore.model.APOD
import xyz.mlumeau.kosmos.kore.data.APODRepositoryCache
import xyz.mlumeau.kosmos.kore.data.APODRepositoryCacheImpl
import xyz.mlumeau.kosmos.kore.data.APODRepositoryRemote
import xyz.mlumeau.kosmos.kore.data.APODRepositoryRemoteImpl
import xyz.mlumeau.kosmos.kore.requestAPOD
import xyz.mlumeau.kosmos.kore.usecases.GetConnectionState
import xyz.mlumeau.kosmos.usecases.GetAPOD

class GetAPODImpl(private val getConnectionState: GetConnectionState) : GetAPOD {

    private val apodRepositoryCache: APODRepositoryCache = APODRepositoryCacheImpl()
    private val apodRepositoryRemote: APODRepositoryRemote = APODRepositoryRemoteImpl()

    override suspend fun invoke() = if (getConnectionState.isConnectedToNetwork()) {
        apodRepositoryRemote.getAPOD()
    } else {
        apodRepositoryCache.getAPOD()
    }

    override fun getAPOD(completion: (APOD) -&gt; Unit, failure: () -&gt; Unit) {
        requestAPOD(this, completion, failure)
    }
}
</code></pre>
<p>Now create the remote repository interface : <code>.../kore/data/APODRepositoryRemote.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore.data

import xyz.mlumeau.kosmos.kore.model.APOD

interface APODRepositoryRemote {
    suspend fun getAPOD(): APOD?
    fun getAPOD(completion: (APOD) -&gt; Unit, failure: () -&gt; Unit)
}
</code></pre>
<p>and the implementation : <code>.../kore/data/APODRepositoryRemoteImpl.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore.data

import xyz.mlumeau.kosmos.kore.model.APOD
import xyz.mlumeau.kosmos.kore.NasaAPIRemote
import xyz.mlumeau.kosmos.kore.requestAPOD
import xyz.mlumeau.kosmos.kore.service.nasa.NasaApi

class APODRepositoryRemoteImpl : APODRepositoryRemote {
    private val nasaAPI: NasaApi = NasaAPIRemote()

    override suspend fun getAPOD() = nasaAPI.getAPOD()

    override fun getAPOD(completion: (APOD) -&gt; Unit, failure: () -&gt; Unit) {
        requestAPOD(this, completion, failure)
    }
}
</code></pre>
<p>Now update the repository interfaces and implementations to remove the getAPOD with params function (not the suspend one) :<br><code>kore/data/APODRepositoryCache.kt</code></p>
<p><code>kore/data/APODRepositoryCacheImpl.kt</code></p>
<p><code>kore/data/APODRepositoryRemote.kt</code></p>
<p><code>kore/data/APODRepositoryRemoteImpl.kt</code></p>
<pre><code>// fun getAPOD(completion: (APOD) -&gt; Unit, failure: () -&gt; Unit)
</code></pre>
<p>Update the common file : <code>.../kore/common.kt</code><br>Replace the two repositories functions with a single usecase function</p>
<pre><code>package xyz.mlumeau.kosmos.kore

// import xyz.mlumeau.kosmos.kore.data.APODRepositoryCacheImpl
// import xyz.mlumeau.kosmos.kore.data.APODRepositoryRemoteImpl
import xyz.mlumeau.kosmos.kore.usecases.implementations.GetAPODImpl

...

// expect fun requestAPOD(
//     apodRepositoryRemote: APODRepositoryRemoteImpl,
//     completion: (APOD) -&gt; Unit,
//     failure: () -&gt; Unit
// )

// expect fun requestAPOD(
//     apodRepositoryCache: APODRepositoryCacheImpl,
//     completion: (APOD) -&gt; Unit,
//     failure: () -&gt; Unit
// )

expect fun requestAPOD(getAPODImpl: GetAPODImpl, completion: (APOD) -&gt; Unit, failure: () -&gt; Unit)
</code></pre>
<p>Now edit the android directory : <code>workshop-kmp/kore/src/androidMain/kotlin/xyz/mlumeau/kosmos/kore/actual.kt</code><br>Remove the repositories references and replace them with usecases functions</p>
<pre><code>package xyz.mlumeau.kosmos.kore

// import xyz.mlumeau.kosmos.kore.data.APODRepositoryCacheImpl
// import xyz.mlumeau.kosmos.kore.data.APODRepositoryRemoteImpl
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import xyz.mlumeau.kosmos.kore.usecases.implementations.GetAPODImpl

...

// actual fun requestAPOD(
//     apodRepositoryRemote: APODRepositoryRemoteImpl,
//     completion: (APOD) -&gt; Unit,
//     failure: () -&gt; Unit
// ) {
//     TODO(&#34;The Android app must use the suspend function instead.&#34;)
// }

// actual fun requestAPOD(
//     apodRepositoryCache: APODRepositoryCacheImpl,
//     completion: (APOD) -&gt; Unit,
//     failure: () -&gt; Unit
// ) {
//     TODO(&#34;The Android app must use the suspend function instead.&#34;)
// }

actual fun requestAPOD(getAPODImpl: GetAPODImpl, completion: (APOD) -&gt; Unit, failure: () -&gt; Unit) {
    TODO(&#34;The Android app must use the suspend function instead.&#34;)
}
</code></pre>
<p>In the Android main project &#34;androidApp&#34;,</p>
<p>Add a usecase : <code>.../usecases/GetConnectionStateAndroid.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.usecases

import android.net.ConnectivityManager
import android.net.NetworkInfo
import xyz.mlumeau.kosmos.kore.usecases.GetConnectionState

class GetConnectionStateAndroid(
    private val connectivityManager: ConnectivityManager
) : GetConnectionState {
    override fun isConnectedToNetwork(): Boolean {
        val activeNetwork: NetworkInfo? = connectivityManager.activeNetworkInfo
        return activeNetwork?.isConnected == true
    }
}
</code></pre>
<p>Update the viewmodel : <code>.../viewmodels/APODViewModel.kt</code></p>
<pre><code>...
// import xyz.mlumeau.kosmos.kore.data.APODRepositoryRemote
import xyz.mlumeau.kosmos.usecases.GetAPOD

class APODViewModel(
    // private val apodRepository: APODRepositoryRemote
    private val getApodUseCase: GetAPOD
) : ScopedViewModel() {

    ...

    private fun startLoadingData() {
        launch {
            getApodUseCase()?.let { apod -&gt;
                withContext(Dispatchers.Main) {
                    _apod.value = apod
                }
            }
        }
    }
}
</code></pre>
<p>And the factory : <code>.../viewmodels/APODViewModelFactory.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.viewmodels

import android.content.Context
import android.net.ConnectivityManager
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import xyz.mlumeau.kosmos.kore.usecases.GetConnectionState
import xyz.mlumeau.kosmos.kore.usecases.implementations.GetAPODImpl
import xyz.mlumeau.kosmos.usecases.GetConnectionStateAndroid

class APODViewModelFactory(
    private val context: Context
) : ViewModelProvider.Factory {

    @Suppress(&#34;UNCHECKED_CAST&#34;)
    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {
        require(modelClass == APODViewModel::class.java) { &#34;Unknown ViewModel class&#34; }
        val connectivityManager =
            context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val getConnectionState: GetConnectionState = GetConnectionStateAndroid(connectivityManager)
        return APODViewModel(
            GetAPODImpl(getConnectionState)
        ) as T
    }
}
</code></pre>
<p>Update the <code>java/xyz.mlumeau.kosmos.views/MainActivity</code> (Kotlin file) to add a context parameter in the factory constructor :</p>
<pre><code>...
    ViewModelProviders.of(this, APODViewModelFactory(this))[APODViewModel::class.java]
...
</code></pre>
<p>Everything&#39;s fine ???</p>
<h3 is-upgraded>For Mac users :</h3>
<p>Now edit the iOS actual file : <code>workshop-kmp/kore/src/iosMain/kotlin/xyz/mlumeau/kosmos/kore/actual.kt</code></p>
<pre><code>package xyz.mlumeau.kosmos.kore

...
// import xyz.mlumeau.kosmos.kore.data.APODRepositoryCacheImpl
// import xyz.mlumeau.kosmos.kore.data.APODRepositoryRemoteImplimport xyz.mlumeau.kosmos.kore.usecases.implementations.GetAPODImpl

...

// fun getNetworkScope() = MainScope() as CoroutineScope
actual fun getNetworkScope() = MainScope() as CoroutineScope

// actual fun requestAPOD(
//     apodRepositoryRemote: APODRepositoryRemoteImpl,
//     completion: (APOD) -&gt; Unit,
//     failure: () -&gt; Unit
// ) {
//     getNetworkScope().launch {
//         val apod = apodRepositoryRemote.getAPOD()
//         if (apod != null) {
//             completion(apod)
//         } else {
//             failure()
//         }
//     }
// }
// 
// actual fun requestAPOD(
//     apodRepositoryCache: APODRepositoryCacheImpl,
//     completion: (APOD) -&gt; Unit,
//     failure: () -&gt; Unit
// ) {
actual fun requestAPOD(getAPODImpl: GetAPODImpl, completion: (APOD) -&gt; Unit, failure: () -&gt; Unit) {
    MainScope().launch {
        // val apod = apodRepositoryCache.getAPOD()
        val apod = getAPODImpl()
        if (apod != null) {
            completion(apod)
        } else {
            failure()
        }
    }
}
</code></pre>
<p>Back to Xcode !</p>
<p>Add a usecase : <code>.../UseCases/GetConnectionStateIos</code></p>
<pre><code>import UIKit
import SystemConfiguration
import kore

class GetConnectionStateIos: NSObject, GetConnectionState {
    func isConnectedToNetwork() -&gt; Bool {
        var zeroAddress = sockaddr_in(sin_len: 0, sin_family: 0, sin_port: 0, sin_addr: in_addr(s_addr: 0), sin_zero: (0, 0, 0, 0, 0, 0, 0, 0))
        zeroAddress.sin_len = UInt8(MemoryLayout.size(ofValue: zeroAddress))
        zeroAddress.sin_family = sa_family_t(AF_INET)
        
        let defaultRouteReachability = withUnsafePointer(to: &amp;zeroAddress) {
            $0.withMemoryRebound(to: sockaddr.self, capacity: 1) {zeroSockAddress in
                SCNetworkReachabilityCreateWithAddress(nil, zeroSockAddress)
            }
        }
        
        var flags: SCNetworkReachabilityFlags = SCNetworkReachabilityFlags(rawValue: 0)
        if SCNetworkReachabilityGetFlags(defaultRouteReachability!, &amp;flags) == false {
            return false
        }
        
        /* Only Working for WIFI
         let isReachable = flags == .reachable
         let needsConnection = flags == .connectionRequired
         
         return isReachable &amp;&amp; !needsConnection
         */
        
        // Working for Cellular and WIFI
        let isReachable = (flags.rawValue &amp; UInt32(kSCNetworkFlagsReachable)) != 0
        let needsConnection = (flags.rawValue &amp; UInt32(kSCNetworkFlagsConnectionRequired)) != 0
        let ret = (isReachable &amp;&amp; !needsConnection)
        
        return ret
    }
}
</code></pre>
<p>Update the <code>MainViewModel</code> code by replacing the Repository by the use case :</p>
<pre><code>...
final class MainViewModel {
    // private let apodRepository: APODRepositoryRemote = APODRepositoryRemoteImpl()
    private let getConnectionState: GetConnectionState = GetConnectionStateIos()
    private let getApodUseCase: GetAPOD
    ...
    
    init() {
        getApodUseCase = GetAPODImpl(getConnectionState: getConnectionState)
        startLoadingData()
    }
    
    private func startLoadingData() {
        // apodRepository.getAPOD(completion: { apod in
        getApodUseCase.getAPOD(completion: { apod in
            self.apod = apod
            self.onAPODLoaded?(apod)
            return .init()
        }, failure: { () in
            self.onLoadingError?()
            return .init()
        })
    }
}
</code></pre>
<p>You can now compile and run the project to validate the architecture updates !</p>
<h3 is-upgraded>If everything&#39;s fine, let&#39;s go to the step 7 !!!</h3>


      </google-codelab-step>
    
      <google-codelab-step label="STEP SEVEN - Where to Go From Here?" duration="0">
        <h3 is-upgraded>If you reach this step then you are in a very good position to start implementing your own Kotlin Multiplatform code!</h3>
<p>Let&#39;s think about some improvements we can make to this app.</p>
<p>How about improving the <code>GetAPOD</code> use case with a cache management? New APOD data is available every day. Knowing this there is no point making multiple requests to the NASA&#39;s API during the same day. We could then have a cache system which stores the APOD data with an associated time. The <code>APODRepositoryCache</code> will then be able to serve this persisted data and provide information about its expiration. The <code>GetAPOD</code> use case will then be able to decide whether it should use the <code>APODRepositoryCache</code> if cached data is available and not expired or the <code>APODRepositoryRemote</code> to get fresh data.</p>
<p>Let&#39;s modify the <code>APODRepositoryCache</code> interface (<code>xyz.mlumeau.kosmos.kore.data.APODRepositoryCache</code>) and add two methods:</p>
<pre><code>package xyz.mlumeau.kosmos.usecases

import xyz.mlumeau.kosmos.kore.APOD

interface APODRepositoryCache {
    suspend fun getAPOD(): APOD?
    fun setLastCacheTime(lastCache: Long)
    fun isProjectsCacheExpired(): Boolean
}
</code></pre>
<p>It&#39;s now your turn to create your own Kotlin Multiplatform code.</p>
<p>You should first update the implementation of the <code>APODRepositoryCache</code> interface (<code>APODRepositoryCacheImpl</code>) to provide persistence capabilites. You can either choose a plateform specific solution or use some Koltin Multiplatform compatible solution such as <a href="https://www.kotlinresources.com/library/sqldelight/" target="_blank">SQLdelight</a>.</p>
<p>Once you have your improved cache system working, you can then update the <code>GetAPOD</code> use case implementation (<code>GetAPODImpl</code>) to use those new capabilities.</p>
<aside class="special"><p>You reached the end of this workshop. Thank you very much for attending! We hope you enjoyed discovering this new technology. Keep us posted with your results, projects and discoveries about Kotlin Multiplatform. Have fun 🥳!</p>
</aside>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>

</body>
</html>
